{
  "name": "kaiser",
  "description": "Serialization of arbitrary objects",
  "version": "0.0.1",
  "format": "cjs",
  "repository": {
    "type": "git",
    "url": "https://github.com/breuleux/kaiser"
  },
  "keywords": [],
  "author": {
    "name": "Olivier Breuleux"
  },
  "license": "MIT",
  "main": "./lib/index.js",
  "dependencies": {
    "earlgrey-runtime": ">=0.0.10"
  },
  "devDependencies": {
    "earlgrey": ">=0.0.12",
    "mocha": "^2.2.1",
    "earl-mocha": ">=0.0.2"
  },
  "scripts": {
    "refresh": "earl compile -5vso lib/ src/",
    "compile": "earl compile -5rvso lib/ src/",
    "prepublish": "npm run compile",
    "test": "mocha"
  },
  "readme": "\nkaiser\n======\n\nSerialization library that allows arbitrary objects and classes to be\nserialized or deserialized in a safe way.\n\nkaiser can serialize standard JavaScript data, objects, arrays and\ndates out of the box. Anything else must be registered.\n\n\nUsage\n-----\n\nSimple serialization/deserialization\n\n    var kaiser = require(\"kaiser\");\n    var str = kaiser.serialize({a: 1, b: new Date()});\n    var obj = kaiser.deserialize(str);\n\n\n### whitelists\n\nYou can also instantiate a `Serializer` object with a whitelist, which\nmeans only a limited list of approved objects and classes can be\nserialized or deserialized. The resulting serializer, when used on\nunsanitized data, will be as safe as the most unsafe object in the\nwhitelist, so be careful:\n\n    var kaiser = require(\"kaiser\");\n    var s = kaiser.Serializer([Date, Person]);\n\n    var str1 = ser.serialize({a: new Date(), b: new Person()}); // OK!\n    var obj2 = ser.deserialize(str1);                           // OK!\n\n    var str2 = ser.serialize({a: 1, b: new Animal()});          // ERROR!\n\n    var str3 = kaiser.serialize({a: 1, b: new Animal()});       // OK (generic serializer)\n    var obj3 = ser.deserialize(str3);                           // ERROR!\n\n\nRegistering functionality\n-------------------------\n\nTo register with `kaiser` you need to assign a uuid to your class or\nfunction. A uuid is a unique symbol which can identify your\nfunctionality in any application that imports it and will not clash\nwith any other package. There are a few ways to do it, and `kaiser`\ncan help you.\n\nFirst you must import `kaiser`, for that you have two options:\n\n    // Option A: Import the full package\n    kaiser = require(\"kaiser\");\n\n    // Option B: Import only the registering functions\n    kaiser = require(\"kaiser/reg\");\n\nThe difference between the two is that option B only defines a few\nstubs to let you register your classes for serialization and is about\n300 bytes minified, so it is super cheap if you only want to provide\nthe functionality to people who need it. Then when they import the\nfull `kaiser` package, the serializers will get registered for real.\n\nNow, suppose you have the following definition:\n\n    function Vehicle(brand) {\n        this.brand = brand;\n    }\n    Vehicle.prototype.start = function () {\n        console.log(\"vroom vroom!\");\n    }\n\n\n### Use package info\n\nThis will assign `Vehicle` the uuid `npm:my-package/Vehicle`:\n\n    kaiser.register(Vehicle.prototype, {\n        package: {name: \"my-package\", \"version\": \"1.2.3\"}\n    });\n\nThis will assign `Vehicle` the uuid `npm:my-package@1/Vehicle`:\n\n    kaiser.register(Vehicle.prototype, {\n        package: {name: \"my-package\", \"version\": \"1.2.3\"},\n        useVersion: \"major\"\n    });\n\nOf course, if you have a `package.json` file in the same directory,\nyou should simply do this:\n\n    kaiser.register(Vehicle.prototype, {\n        package: require(\"./package.json\"),\n        useVersion: \"minor\"\n    });\n\nTo register more than one class, use `kaiser.registerAll`:\n\n    kaiser.registerAll([Vehicle.prototype, Animal.prototype], {\n        package: require(\"./package.json\"),\n        useVersion: \"minor\"\n    });\n\n\n### uuid\n\nInstall the `uuid` command on your system and run it. It will give you\na (presumably) unique hexadecimal identifier that you can paste in\nyour code:\n\n    $ uuid\n    bfd249d8-302a-11e5-8044-278351ad39e9\n\nThen you must set the `typeId` field:\n\n    kaiser.register(Vehicle.prototype, {\n        typeId: \"bfd249d8-302a-11e5-8044-278351ad39e9\"\n    });\n\n`kaiser.registerAll` can be used with just one `typeId`. What it will\ndo is that it will generate ids like\n`bfd249d8-302a-11e5-8044-278351ad39e9/Vehicle` and so on.\n\n\n### uuid interface\n\nIn order to generate a uuid, `kaiser` follows these steps:\n\n* If the configuration object contains:\n* `typeId` and `variant`: `typeId + JSON.stringify(variant)`\n* `typeId` and `nameVariant === true`: `typeId + object.name`\n* `typeId` and `nameVariant`: `typeId + nameVariant`\n* `typeId`: `typeId`\n* `package` and `useVersion`: `package@version/object.name`\n\nNote that `registerAll` and `registerSingletons` automatically set\n`nameVariant` in order to differentiate the entries. It is thus\nimportant that they all have names.\n\n\nRegistering functions and singletons\n------------------------------------\n\nBy default, `kaiser` understands that what is being registered is a\nprototype, and that objects that directly inherit from the prototype\nare those that we wish to serialize.\n\nOn the other hand, you may want to serialize functions, or objects\nas-is. To that purpose you may use `kaiser.registerFunction` or\n`kaiser.registerSingleton` (they are the same thing). Both functions\nhave a plural equivalent that lets you register more than one thing at\nonce.\n\n\n    function hello(name) {\n        return \"hello, \" + name\n    }\n    function bye(name) {\n        return \"bye, \" + name\n    }\n\n    kaiser.registerSingletons([hello, bye], {\n        package: require(\"./package.json\"),\n        useVersion: \"patch\"\n    });\n\n\nThe above will registers ids \"npm:my-package@1.2.3/hello\" and\n\"npm:my-package@1.2.3/bye\".\n\n\nCustom serialization\n--------------------\n\nBy default `kaiser.serialize` will pack all the fields in an object\nand `kaiser.deserialize` will instantiate an object with the right\nprototype and write the fields back.\n\nBut you can change this. Here is a simple example (of a flawed\nserialization mechanism):\n\n    kaiser.register(Person.prototype, {\n        typeId: \"bfd249d8-302a-11e5-8044-278351ad39e9\",\n        serialize: function (person) {\n            return person.name + \"/\" + person.age;\n        },\n        deserialize: function (person) {\n            fields = person.split(\"/\");\n            return new Person(fields[0], parseInt(fields[1]));\n        }\n    });\n\nThe serialization and deserialization interface is as follows:\n\n**`serialize(object)`** must return either some primitive type like a\nString or Number, or a plain object or array in which the fields are\n*not serialized* (in other words, do not call `kaiser.serialize` in\nthat function). `kaiser` will serialize these fields for you so that\nyou can focus on the logic.\n\n**`deserialize(form)`** must rebuild the object previously serialized\nexactly. It will receive the same output serialize produced, with\nalready deserialized fields (do not call `kaiser.deserialize` in that\nfunction).\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/breuleux/kaiser/issues"
  },
  "homepage": "https://github.com/breuleux/kaiser",
  "_id": "kaiser@0.0.1",
  "dist": {
    "shasum": "525c6bdd1ea91caedb435599b64e6e99546df2bb"
  },
  "_from": "kaiser@",
  "_resolved": "https://registry.npmjs.org/kaiser/-/kaiser-0.0.1.tgz"
}
