
provide:

   TYPEID

   Serializer
   default-serializer
   serialize, deserialize
   shallow-copy, deep-copy

   register, register-all
   register-singleton, register-singletons
   register-function, register-functions

   true as loaded


if global["@@KAISER"]??.loaded:
   return global["@@KAISER"]


;;;;;;;;;;;;;
;; Symbols ;;
;;;;;;;;;;;;;

TYPEID = Symbol{.TYPEID}



;;;;;;;;;;;;;;
;; Registry ;;
;;;;;;;;;;;;;;


registry = {=}

object-name{object, req = false} =
   match object??.name or object??.constructor??.name:
      false? when req ->
         throw E.kaiser.name-required with
            "The object or function to register must have a name field or its constructor must have a name."
      false? ->
         ""
      name -> name

make-type-id{object, match policy} =
   {=> type-id, => variant} -> type-id + "/" + JSON.stringify{variant}
   {=> type-id, name-variant => match} ->
      === true -> type-id + "/" + object-name{object}
      name-variant -> type-id + "/" + name-variant
   {=> type-id} -> type-id
   {=> package, => use-version = null} ->
      version = match use-version:
         false? -> ""
         do: data-version = if{package.dataVersion as dv, 'd{dv}', package.version}
         .major -> '@{data-version.split{"."}[0]}'
         .minor -> '@{data-version.split{"."}[0...2].join{"."}}'
         .patch -> '@{data-version}'
      'npm:{package.name}{version}/{object-name{object}}'
   else ->
      throw E.kaiser.register.id{"No typeId provided."}


register{object, _policy} =

   policy = object-serializer{object} & _policy

   if policy.target !== .self and object.prototype and not policy.ignore-prototype:
      return register{object.prototype, _policy}

   policy.type-id and type-id = make-type-id{object, policy}

   if Object.is-frozen{object}:
      throw E.kaiser.frozen with
         "kaiser cannot register frozen objects as serializable types; "
         \ + "either register them before freezing them, or register their prototypes."

   prev = registry[type-id]
   if prev and prev !== policy:
      match prev.on-duplicate:
         .error or when policy.on-duplicate === .error ->
            throw E.kaiser.duplicate-id with 
               'Duplicate typeId: "{type-id}". You can control this error'
               \ + ' with the onDuplicate option to kaiser.register'
               \ + ' (onDuplicate: "error" (default), "(warn-)keep" or "(warn-)replace").'
         .warn-keep ->
            console.warn{'WARNING: Duplicate typeId: "{type-id}". Keeping previous.'}
            return false
         .warn or .warn-replace ->
            console.warn{'WARNING: Duplicate typeId: "{type-id}". Replacing.'}
         .keep ->
            return false
         .replace ->
            pass

   registry[type-id] = policy
   object[TYPEID] = type-id
   true

register-all{objects, policy} =
   objects each object ->
      register{object, policy & {name-variant = object-name{object}}}


object-serializer{proto} = {
   on-duplicate = .error
   target = .direct
   ignore-prototype = false
   serialize{x} = object with items{x}
   deserialize{x} =
      rval = Object.create{proto}
      items{x} each {k, v} -> rval[k] = v
      rval
}

singleton-serializer{object} = {
   target = "self"
   serialize{_} = null
   deserialize{_} = object
}

register-singleton{object, match = null} =
   null? ->
      {o} -> register-singleton{o, object}
   String? type-id ->
      register{object, singleton-serializer{object} & {= type-id}}
      object
   policy ->
      register{object, singleton-serializer{object} & policy}
      object

register-singletons{objects, _policy} =
   policy = match _policy:
      String? type-id -> {= type-id}
      else -> _policy
   objects each object ->
      register{object, singleton-serializer{object} & [policy & {name-variant = object-name{object}}]}

register-function = register-singleton
register-functions = register-singletons



;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Serialize/deserialize ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

class Serializer:

   constructor{match white-list = null} =
      null? ->
         @white-list = null
      else ->
         @white-list and wl = {
            native = true
            "builtin:Object" = true
         }
         acquire{white-list or {}} where acquire{match w} =
            Array? ->
               w each entry -> acquire{entry}
            String? ->
               wl[w] = true
            {prototype => {^TYPEID => tid}} ->
               wl[tid] = true
            {^TYPEID => tid} ->
               wl[tid] = true

   to-object{match obj, recursive = true} =
      null? or undefined? or Boolean? or Number? or String? ->
         {type-id = 'native', data = obj}
      Array? when recursive ->
         obj each x -> @to-object{x}
      Array? ->
         obj each x -> x
      else ->
         tid = obj[TYPEID]
         if not tid:
            throw E.kaiser.serialize{'Object has no typeId and cannot be serialized: {obj}'}
         if @white-list and not @white-list[tid]:
            throw E.kaiser.serialize{'Object with type id "{tid}" is not white-listed for serialization: {obj}'}
         ser0 = match registry[tid]:
            undefined? ->
               throw E.kaiser.serialize{'Cannot serialize typeId: "{tid}" for object {obj}'}
            policy and {target => match} ->
               .self when not Object.has-own-property.call{obj, TYPEID} ->
                  throw E.kaiser.serialize with
                     'Object has no typeId and cannot be serialized: {obj} [1]'
               .direct and p is Object.get-prototype-of{obj} when not p.has-own-property.call{p, TYPEID} ->
                  throw E.kaiser.serialize with
                     'Object has no typeId and cannot be serialized: {obj} [2]'
               else ->
                  policy.serialize{obj}
         ser1 =
            match ser0:
               when not recursive ->
                  ser0
               null? or undefined? or String? or Number? or Boolean? ->
                  ser0
               Array? ->
                  ser0 each x -> @to-object{x}
               Object? ->
                  object with items{ser0} each {k, v} -> {k, @to-object{v}}
         {type-id = tid, data = ser1}

   from-object{match obj, recursive = true} =
      Array? when recursive ->
         obj each x -> @from-object{x}
      Array? ->
         obj each x -> x
      else ->
         tid = obj.type-id
         if @white-list and not @white-list[tid]:
            throw E.kaiser.deserialize{'Cannot deserialize {obj.data} because typeId "{tid}" is not in the whitelist'}
         match tid:
            .native ->
               obj.data
            else ->
               deser = match registry[tid]:
                  undefined? ->
                     throw E.kaiser.deserialize{'No deserializer for typeId "{tid}"'}
                  policy ->
                     policy.deserialize with match obj.data as data:
                        when not recursive ->
                           object with items{data}
                        null? or undefined? or String? or Number? or Boolean? ->
                           data
                        Array? ->
                           data each x -> @from-object{x}
                        Object? ->
                           object with items{data} each {k, v} ->
                              {k, @from-object{v}}
      

   serialize{obj} =
      JSON.stringify{@to-object{obj}}

   deserialize{repr} =
      @from-object{JSON.parse{repr}}

   shallow-copy{obj} =
      @from-object{@to-object{obj, false}, false}

   deep-copy{obj} =
      @from-object{@to-object{obj}}


default-serializer = Serializer{}

serialize = default-serializer.serialize.bind{default-serializer}
deserialize = default-serializer.deserialize.bind{default-serializer}
shallow-copy = default-serializer.shallow-copy.bind{default-serializer}
deep-copy = default-serializer.deep-copy.bind{default-serializer}



;;;;;;;;;;;;;;
;; BUILTINS ;;
;;;;;;;;;;;;;;

register{Object.prototype} with {
   type-id = "builtin:Object"
   on-duplicate = .error
   target = .direct
   serialize{obj} =
      obj
   deserialize{obj} =
      obj
}

register{Date.prototype} with {
   type-id = "builtin:Date"
   on-duplicate = .error
   target = .direct
   serialize{obj} =
      String{obj}
   deserialize{s} =
      new Date{s}
}

register{Error.prototype} with {
   type-id = "builtin:Error"
   on-duplicate = .error
   target = .direct
   serialize{obj} =
      rval = object with items{obj}
      rval.message = obj.message
      rval.stack = obj.stack
      if obj[Symbol.error-tags]:
         rval["::tags"] = obj[Symbol.error-tags]
      rval
   deserialize{s} =
      e = Error{s.message}
      items{s} each {k, v} when not k in {.message, "::tags"} ->
         e[k] = v
      e.stack = s.stack
      if s["::tags"]:
         e[Symbol.error-tags] = s["::tags"]
      e
}

cmds = {= register, = register-all
        = register-singleton, = register-singletons
        = register-function, = register-functions}

[global["@@KAISER"]??.waiting-list or {}] each {cmd, args} ->
   cmds[cmd][args]
global["@@KAISER"] = module.exports

